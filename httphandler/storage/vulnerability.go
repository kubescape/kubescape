package storage

import (
	"context"
	"fmt"
	"time"

	"github.com/kubescape/go-logger"
	"github.com/kubescape/go-logger/helpers"
	"github.com/kubescape/kubescape/v3/core/cautils"
	"github.com/kubescape/storage/pkg/apis/softwarecomposition/v1beta1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/client-go/util/retry"
)


// Ensure APIServerStore implements VulnerabilityRepository
var _ VulnerabilityRepository = (*APIServerStore)(nil)

// StoreVulnerabilityManifest stores vulnerability manifest in both kubescape and workload namespaces
// This addresses GitHub issue #1731 by making VulnerabilityManifest available in workload namespace
func (a *APIServerStore) StoreVulnerabilityManifest(ctx context.Context, imageScanData *cautils.ImageScanData, workloadNamespace string) error {
	if imageScanData == nil {
		return fmt.Errorf("imageScanData cannot be nil")
	}

	// Create manifest for workload namespace (primary location for users)
	workloadManifest, err := a.createVulnerabilityManifest(ctx, imageScanData, workloadNamespace)
	if err != nil {
		return fmt.Errorf("failed to create workload namespace vulnerability manifest: %w", err)
	}

	// Store in workload namespace
	if err := a.storeManifestInNamespace(ctx, workloadManifest, workloadNamespace); err != nil {
		return fmt.Errorf("failed to store vulnerability manifest in workload namespace %s: %w", workloadNamespace, err)
	}

	// For backward compatibility, also store in kubescape namespace
	if workloadNamespace != a.namespace { // Avoid duplicate if workload is already kubescape
		kubescapeManifest := workloadManifest.DeepCopy()
		if err := a.storeManifestInNamespace(ctx, kubescapeManifest, a.namespace); err != nil {
			logger.L().Ctx(ctx).Warning("failed to store backward-compatible vulnerability manifest in kubescape namespace",
				helpers.String("workloadNamespace", workloadNamespace),
				helpers.String("kubescapeNamespace", a.namespace),
				helpers.Error(err))
			// Don't fail the operation if backward compatibility store fails
		}
	}

	logger.L().Ctx(ctx).Debug("stored vulnerability manifest in dual namespaces",
		helpers.String("name", workloadManifest.Name),
		helpers.String("workloadNamespace", workloadNamespace),
		helpers.String("kubescapeNamespace", a.namespace))

	return nil
}

// createVulnerabilityManifest creates a VulnerabilityManifest from image scan data
func (a *APIServerStore) createVulnerabilityManifest(ctx context.Context, imageScanData *cautils.ImageScanData, namespace string) (*v1beta1.VulnerabilityManifest, error) {
	if imageScanData.Image == "" {
		return nil, fmt.Errorf("image name cannot be empty")
	}

	// Generate a unique name for the manifest based on image
	manifestName := generateVulnerabilityManifestName(imageScanData.Image, "")

	// Convert scan results to grype document format
	payload, err := a.convertScanResultsToGrypeDocument(ctx, imageScanData)
	if err != nil {
		return nil, fmt.Errorf("failed to convert scan results: %w", err)
	}

	// Create labels and annotations
	labels := map[string]string{
		"kubescape.io/image":        imageScanData.Image,
		"kubescape.io/cluster":      a.clusterName,
		"kubescape.io/vulnerability": "true",
	}

	annotations := map[string]string{
		"kubescape.io/scan-time": time.Now().Format(time.RFC3339),
	}

	manifest := &v1beta1.VulnerabilityManifest{
		ObjectMeta: metav1.ObjectMeta{
			Name:        manifestName,
			Namespace:   namespace, // Will be set by caller
			Labels:      labels,
			Annotations: annotations,
		},
		Spec: v1beta1.VulnerabilityManifestSpec{
			Metadata: v1beta1.VulnerabilityManifestMeta{
				WithRelevancy: true,
				Tool: v1beta1.VulnerabilityManifestToolMeta{
					Name:    "kubescape",
					Version: "v3",
				},
				Report: v1beta1.VulnerabilityManifestReportMeta{
					CreatedAt: metav1.Now(),
				},
			},
			Payload: *payload,
		},
	}

	return manifest, nil
}

// storeManifestInNamespace stores a vulnerability manifest in the specified namespace
func (a *APIServerStore) storeManifestInNamespace(ctx context.Context, manifest *v1beta1.VulnerabilityManifest, namespace string) error {
	// Set the namespace
	manifest.Namespace = namespace

	// Try to create the manifest
	_, err := a.StorageClient.VulnerabilityManifests(namespace).Create(ctx, manifest, metav1.CreateOptions{})

	if errors.IsAlreadyExists(err) {
		// If it already exists, update it
		return retry.RetryOnConflict(retry.DefaultRetry, func() error {
			existing, getErr := a.StorageClient.VulnerabilityManifests(namespace).Get(ctx, manifest.Name, metav1.GetOptions{})
			if getErr != nil {
				return getErr
			}

			// Update the spec
			existing.Spec = manifest.Spec

			// Merge labels and annotations
			if existing.Labels == nil {
				existing.Labels = make(map[string]string)
			}
			for k, v := range manifest.Labels {
				existing.Labels[k] = v
			}

			if existing.Annotations == nil {
				existing.Annotations = make(map[string]string)
			}
			for k, v := range manifest.Annotations {
				existing.Annotations[k] = v
			}

			_, updateErr := a.StorageClient.VulnerabilityManifests(namespace).Update(ctx, existing, metav1.UpdateOptions{})
			return updateErr
		})
	}

	if err != nil {
		return fmt.Errorf("failed to store vulnerability manifest %s in namespace %s: %w", manifest.Name, namespace, err)
	}

	logger.L().Ctx(ctx).Debug("stored vulnerability manifest",
		helpers.String("name", manifest.Name),
		helpers.String("namespace", namespace))

	return nil
}

// GetVulnerabilityManifest retrieves a vulnerability manifest from the specified namespace
func (a *APIServerStore) GetVulnerabilityManifest(ctx context.Context, name, namespace string) (*v1beta1.VulnerabilityManifest, error) {
	return a.StorageClient.VulnerabilityManifests(namespace).Get(ctx, name, metav1.GetOptions{})
}

// convertScanResultsToGrypeDocument converts image scan data to GrypeDocument format
func (a *APIServerStore) convertScanResultsToGrypeDocument(ctx context.Context, imageScanData *cautils.ImageScanData) (*v1beta1.GrypeDocument, error) {
	// Convert the image scan data to a Grype document
	// For now, we'll create a basic structure. In a real implementation,
	// this would convert the actual scan results to the proper Grype format.

	doc := &v1beta1.GrypeDocument{
		Matches: []v1beta1.Match{}, // Would be populated from imageScanData.Matches
	}

	// For a complete implementation, we would populate:
	// - Matches from imageScanData.Matches
	// - Source information
	// - Descriptor information
	// - SBOM if available

	return doc, nil
}

// generateVulnerabilityManifestName generates a unique name for the vulnerability manifest
func generateVulnerabilityManifestName(image, imageHash string) string {
	if imageHash != "" && len(imageHash) >= 16 {
		return fmt.Sprintf("%s-%s", sanitizeName(image), imageHash[:16])
	}
	return sanitizeName(image)
}

// sanitizeName sanitizes a string to be used as a Kubernetes resource name
func sanitizeName(name string) string {
	// Replace invalid characters with hyphens
	// Keep only alphanumeric characters, hyphens, and dots
	sanitized := ""
	for _, r := range name {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '-' || r == '.' {
			sanitized += string(r)
		} else {
			sanitized += "-"
		}
	}

	// Ensure it doesn't start or end with hyphens
	for len(sanitized) > 0 && sanitized[0] == '-' {
		sanitized = sanitized[1:]
	}
	for len(sanitized) > 0 && sanitized[len(sanitized)-1] == '-' {
		sanitized = sanitized[:len(sanitized)-1]
	}

	// Limit length to 253 characters (Kubernetes limit)
	if len(sanitized) > 253 {
		sanitized = sanitized[:253]
		for len(sanitized) > 0 && sanitized[len(sanitized)-1] == '-' {
			sanitized = sanitized[:len(sanitized)-1]
		}
	}

	// Ensure minimum length
	if len(sanitized) == 0 {
		sanitized = "unknown"
	}

	return sanitized
}
